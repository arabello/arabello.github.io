{"pageProps":{"post":{"title":"Practicing Typescript: Generalized Algebraic Data Types","publishDate":"2023-02-25","lastUpdate":"2023-02-25","tags":["typescript","algebraic data types","pattern matching","scala"],"description":"How GADT and Pattern Matching look like in Typescript? Let's find out through an hands-on exercise","content":"On November 11th 2023, [we](https://buildo.com/) hosted the [Scala Italy](https://www.scala-italy.it/) meetup in our Milanâ€™s office. A talk by [Nicolas Rinaudo](https://nrinaudo.github.io/) titled _[\"Far more than youâ€™ve ever wanted to know about ADTsâ€$^{1}$](https://www.scala-italy.it/speakers/nicolas-rinaudo)_ grabbed my attention. Algebraic Data Types (ADT) is a noteworthy concept in Software Engineering, particularly in functional programming and type theory. Thanks to this presentation, I better realized its effectiveness on a more pragmatic level.\n\nAt the same time I was looking deeper into Typescriptâ€™s type system, so I asked myself:\n\n> â€œHow Generalized Algebraic Data Types (GADT) and Pattern Matching would look like in Typescript?â€\n\nThis post aims to answer it. Keep in mind, it's not a deep theoretical analysis, but an attempt for a practical insight on ADTs and Pattern Matching.\n\nAs a toy case study, we model a naive payment transactions system with the following assumptions:\n\n- Transaction-specific commands: `validate` and `process`\n- A command to alert users: `notify`\n- A transaction may be in `unprocessed` or `processed` status.\n\n---\n\n## ADT Fundamentals\n\nLet's quickly recall the basic ADT concepts$^{2}$ before starting coding.\n\nA _sum type_ is aÂ disjointÂ union of values (sets). In plain words, the sum of a given two or more types is a set containing the values of one of the component types. Essentially, it is like a logical `OR` (disjunction) between types.\n\n```\nSum(A, B) = A OR B\n```\n\nIt expresses the _alternation_ of the component types: `A` or `B` , but not both.\n\nThe simplest sum type we can think of is `boolean` which is the sum type of `true` and `false` .\n\n- `true` is a set containing a single value\n- `false` is a set containing a single value\n- `boolean` is a set containing either the `true` or `false` value\n\n```\nboolean = true OR false\n```\n\nWhy â€œ_sumâ€_ type? Because its cardinality (number of possible values) is the algebraic _sum_ of the cardinalities of its component types.\n\n```\nBoolean_cardinality = true_cardinality + false_cardinality = 1 + 1 = 2\n```\n\nA _product_ type is compounded structure containing values of various types. In plain words, the product of a given two or more types is a collection of all the component types. Essentially, it is like a logical `AND` (conjunction) between types.\n\n```\nProduct(A, B) = A AND B\n```\n\nIt corresponds to the Cartesian product in set theory and it expresses the _combination_ of the component types: `A` and `B` together.\n\n`tuple` and `records` data structures are examples of product types.\n\n```\nBooleanTuple = [Boolean, Boolean]\n```\n\nWhy â€œ_productâ€_ type? Because its cardinality (number of possible values) is the algebraic _product_ of the cardinalities of its component types. For instance, variables of `BooleanTuple` type can assume 4 values\n\n```tsx\n[true, false]\n[false, true]\n[true, true]\n[false, false]\n```\n\nas\n\n```tsx\nBooleanTuple_cardinality = Boolean_cardinality * Boolean_cardinality = 2 * 2 = 4\n```\n\nAn Algebraic Data Type (ADT) is a potentially recursive sum type of product types, ie. an arbitrary structure repeatedly combining sum and products types. For instance:\n\n```\nADT = A OR (C AND D) OR {nested: ADT}\n```\n\nWe are now ready to see how these concepts apply in Typescript, but first a little disclaimer on formality:\n\n> In languages with a nominal type system like Scala, defining a sum or product type produces _new_ types with a new set of potential values. Therefore, the above formal definitions \\*\\*\\*\\*are valid at implementation level.\n\nInstead, in a structural type system, all possible values already exist: new types merely define sub-sets. Therefore, we cannot create sum or product types in Typescript as per formal definitions: we can only describe already existing _nominal_ types. Nevertheless, from a practical standpoint, we can define types _acting like_ the sum and product types \\*\\*and still fully meet our objectives.\n\n>\n\n---\n\n## Basic ADT\n\nIn Typescript, the union `|` type operator creates a disjoint (discriminated) union between types. It's a useful tool for shaping our transaction commands.\n\n```tsx\ntype Command = \"validate\" | \"process\" | \"notify\";\n```\n\nGiven a value of standard union type, the compiler cannot infer, without type guards, which of the component type is at a given moment.\n\nA _discriminator_ field, ie. a literal type property, helps the compiler to differentiate between the variants. Such types are known as _tagged unions$^{3}$_ and they qualify as _sum types._\n\n```tsx\ntype Command = { _type: \"validate\" } | { _type: \"process\" } | { _type: \"notify\" };\n```\n\nCommands may require extra details to carry out their tasks. For instance:\n\n```tsx\nexport type Command =\n  | { _type: \"validate\"; transactionId: string }\n  | { _type: \"process\"; transactionId: string }\n  | { _type: \"notify\"; userId: string };\n```\n\nThe `Command` type acts as contract with the outside world; consumers may use constructors to create commands with ease, for example:\n\n```tsx\nexport const validate = (transactionId: string): Command => ({\n  _type: \"validate\",\n  transactionId: \"<uuid>\",\n});\n```\n\nSuppose we intend to combine or _chain_ commands like `validate` and `process`. How can we set this up?\n\nWe can extend the `Command` definition with a new compounded type acting as a container for commands themselves.\n\n```tsx\nexport type Command =\n  | { _type: \"validate\"; transactionId: string }\n  | { _type: \"process\"; transactionId: string }\n  | { _type: \"notify\"; userId: string }\n  | { _type: \"chain\"; _cmd1: Command; _cmd2: Command };\n```\n\nThe `chain` container acts as a _product type_ enabling the recursively combination of `Command` values, even another `chain`. We notice that `Command` is now an ADT because it is:\n\n- a recursive\n- sum type\n- of product types\n\n---\n\n# Pattern Matching\n\nSuppose an arbitrary state for our transactions system\n\n```tsx\ntype State = {\n  /** */\n};\n```\n\nand a function that computes the new state based on a `Command` used to execute the system business logic.\n\n```tsx\nconst nextState = (prev: State, command: Command): State => {\n  /** */\n};\n```\n\nOur goal is to provide a skeleton for `nextState` implementation, ensuring that:\n\n- The `Command` type is properly discriminated and narrowed, allowing safe data access for each command according to its type.\n- Logical branches should be fully exhausted, meaning that `Command` cases must be precisely recognized and managed at compile time. If a new command is added or removed without a proper handling, a compile error should be raised.\n\n## Naive switch\n\nWe can begin in the simplest way by applying a switch statement to the discriminator field.\n\n```tsx\nconst nextState = (prev: State, command: Command): State => {\n  switch (command._type) {\n    case \"validate\":\n      command.userId; // compile time error\n      return prev;\n    case \"process\":\n      // ...\n      return prev;\n    case \"notify\":\n      // ...\n      return prev;\n    case \"chain\":\n      // ...\n      return prev;\n  }\n};\n```\n\nThe `command` type is narrowed within each branch. For example, trying to access the `userId` property inside the `validate` case results in a compilation error.\n\n```\nProperty 'userId' does not exist on type '{ _type: \"validate\"; transactionId: string; }'. ts(2339)\n```\n\nThis meets our first goal. Now, letâ€™s add a new `Command` component type.\n\n```tsx\nexport type Command =\n  // [...]\n  { _type: \"newCommand\" };\n```\n\nThe compiler raises an error on the `nextState` function\n\n```\nFunction lacks ending return statement and return type does not include 'undefined'. ts(2366)\n```\n\nstating that the functionâ€™s return type can be `State | undefined` due to the switch statement being _non_-exhaustive. The error is raised as a mismatch between the declared and the inferred return type.\n\nWe may drop the explicit declaration, but we would move the responsibility of a producerâ€™s change to the consumer!\n\n```diff\n- const nextState = (prev: State, command: Command): State => { /** */ }\n+ const nextState = (prev: State, command: Command) => { /** */ }\n---\t ^ inferred return type is State | undefined\n```\n\n```tsx\n// Consumer\nconst newState: State = nextState(prevState, validate(\"123\"));\n//\t^ Type 'State | undefined' is not assignable to type 'State'.\n//\t\tType 'undefined' is not assignable to type 'State'.ts(2322)\n```\n\nAdditionally, there are other limitations when working with the native switch. For example\n\n- The inability to use logical operators in the case statement. The reason being, the logical expressions are evaluated before being compared to theÂ switchÂ value.\n- It does not restrict developers from duplicating a branch because the switch statement only compares values.\n\n```tsx\nconst nextState = (prev: State, command: Command): State => {\n  switch (command._type) {\n    case \"validate\" || \"process\": // â›”ï¸ Always \"validate\"\n      // ...\n      return prev;\n    case \"process\":\n      // ...\n      return prev;\n    case \"process\": // â›”ï¸ Duplicated branch: compiler won't complain\n      // ...\n      return prev;\n    case \"notify\":\n      // ...\n      return prev;\n    case \"chain\":\n      // ...\n      return prev;\n  }\n};\n```\n\nWith reference to our secondary objective, the resulting developer experience and potential side effects isn't great. Is there room for improvement?\n\n## Third Party Pattern Matching\n\n[Pattern matching is a mechanism for checking a value against a pattern](https://docs.scala-lang.org/tour/pattern-matching.html). A successful match can also _deconstruct_ a value into its constituent parts.\n\nUnfortunately, Typescript does not _yet_ (ðŸ¤ž) provide a native pattern matching, but we can rely on third-party libraries.\n\nThe one I am most content with is [](https://github.com/gvergnaud/ts-pattern)_ts-pattern._ I would not dive into the syntax and mechanisms of the library: it is pretty intuitive and its [documentation](https://github.com/gvergnaud/ts-pattern) is well-written. I would focus on the benefits of using _ts-pattern_.\n\nLetâ€™s refactor `nextState`.\n\n```tsx\nimport { match } from \"ts-pattern\";\n\ntype State = {\n  /** */\n};\n\nconst nextState = (prev: State, command: Command): State =>\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) => {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"process\" }, (cmd) => {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"notify\" }, (cmd) => {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"chain\" }, (cmd) => {\n      // ...\n      return prev;\n    })\n    .exhaustive();\n```\n\nSimilarly as before\n\n- we are discriminating over the `_type` field by matching on a portion of the command object\n- the `cmd` variable is properly narrowed\n- branches are exhaustive\n\nIf we remove the `notify` command branch we get an error on the `exhaustive` call\n\n```\nThis expression is not callable.\n\tType 'NonExhaustiveError<{ _type: \"notify\"; userId: string; }>' has no call signatures.ts(2349)\n```\n\nwith a pretty straightforward description.\n\nNote that the error is locally raised inside the function, even if we remove the return type declaration! I want to underlying this fact from an architectural point of view as a difference compared to the previous usage of switch statement. What if the `nextState` function firm is a software module boundary that other parts of our architecture depends on? Should adding, removing, or updating a command indirectly impacts how the consumers use the function?\n\nIn this way the contract with the outside world is stable even if the producer makes internal changes _and_ the function firm is not explicitly declared. Instead of placing the burden of boundary responsibility on the developer, who may choose not to declare the return type, we're making better use of the type system inference.\n\n```diff\n- const nextState = (prev: State, command: Command): State => { /** */ }\n+ const nextState = (prev: State, command: Command) => { /** */ }\n---\t    ^ inferred return type is State | undefined\n--- compile error inside nextState\n```\n\n```tsx\n// Consumer\nconst newState: State = nextState(prevState, validate(\"123\"));\n//\tâœ… No error\n```\n\nAdditionally, _ts-pattern_ addresses the limitations found previously\n\n```tsx\nconst nextState(prev: State, command: Command): State =>\n\tmatch(command)\n\t.with({ _type: P.union(\"validate\", \"process\") }, (cmd) => { // âœ… Logic OR\n\t  // ...\n\t  return prev;\n\t})\n\t.with({ _type: \"notify\" }, (cmd) => {\n\t  // ...\n\t  return prev;\n\t})\n\t\t.with({ _type: \"notify\" }, (cmd) => {.\t\t\t\t\t  // âœ… Compile error raised on duplicated branch\n\t  // ...\n\t  return prev\n\t})\n\t.with({ _type: \"chain\" }, (cmd) => {\n\t  // ...\n\t  return prev;\n\t})\n\t.exhaustive();\n```\n\n_ts-pattern_ offers lots of other [features](https://github.com/gvergnaud/ts-pattern?tab=readme-ov-file#features), I heartily suggest looking into them.\n\n# Generalized ADT for safe composition\n\nLetâ€™s encode the status of transactions in our system\n\n```tsx\nexport type Status = \"unprocessed\" | \"processed\";\n```\n\nand how a command modifies a transactionâ€™s status.\n\n```tsx\nexport type Command<B extends Status, A extends Status> =\n  | { _type: \"validate\"; _before: B; _after: A; transactionId: string }\n  | { _type: \"process\"; _before: B; _after: A; transactionId: string }\n  | { _type: \"notify\"; _before: B; _after: A; userId: string }\n  | {\n      _type: \"chain\";\n      _before: B;\n      _after: A;\n      _cmd1: Command<B, Status>;\n      _cmd2: Command<Status, A>;\n    };\n```\n\nThe `B` (Before) and `A` (After) parametric types indicate that a command can be used on a transaction possessing a specific `Status` (`_before`) and results in a transaction with an identical or different `Status` (`_after`). When parametric types are describing properties of a sum type, they are referred to as _witness_ types$^{4}$: they enable the ADT types refinement at construction time.\n\nIn other words, we can now impose stricter constraints for parametric types in the constructors to refine our ADT$^{5}$. This results in a _Generalized ADT_: a sum type with one or more witness types, each featuring type equality.\n\nAssume that\n\n- `validate: \"unprocessed\" -> \"unprocessed\"`\n- `process: \"unprocessed\" -> \"processed\"`\n- `notify: \"processed\" -> \"processed\"`\n\nwe refactor our constructors to _refine_ the status transition per each type variant, for example\n\n```tsx\nexport const validate = (transactionId: string): Command<\"unprocessed\", \"unprocessed\"> => ({\n  _type: \"validate\",\n  _before: \"unprocessed\",\n  _after: \"unprocessed\",\n  transactionId,\n});\n```\n\nHowever, if we use the constructor\n\n```tsx\nexport const y: Command<\"unprocessed\", \"unprocessed\"> = validate(\"1\");\ny._type; // \"validate\" | \"process\" | \"notify\" | \"chain\"\ny._before; // \"unprocessed\"\ny._after; // \"unprocessed\"\n```\n\nwe notice that the `_type` discriminating property is not correctly narrowed due to the lack of connection between `_type`, `_before` and `_after` of each `Command` component type.\n\nDually, in the `nextState` function refactored with the new `Command`\n\n```tsx\nconst nextState = (prev: {}, command: Command<Status, Status>) =>\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) => {\n      cmd._before; // Status\n      cmd._after; // Status\n    })\n    .with({ _type: \"process\" }, (cmd) => {})\n    .with({ _type: \"notify\" }, (cmd) => {})\n    .with({ _type: \"chain\" }, (cmd) => {\n      nextState(prev, cmd._cmd1);\n      nextState(prev, cmd._cmd2);\n    })\n    .exhaustive();\n```\n\nthe `_before` and `_after` properties are not narrowed based on the discriminating `_type` field.\n\nAnother relevant issue is that the `chain` command constructor\n\n```tsx\nexport const chain = (\n  cmd1: Command<Status, Status>,\n  cmd2: Command<Status, Status>,\n): Command<Status, Status> => ({\n  _type: \"chain\",\n  _before: cmd1._before,\n  _after: cmd2._after,\n  _cmd1: cmd1,\n  _cmd2: cmd2,\n});\n```\n\nallows to compose two transactions of _any_ status. For example, the type system allows for\n\n```tsx\nconst x: Command<Status, Status> = chain(validate(\"1\"), notify(\"1\"));\n```\n\neven though `validate` ending status is not compatible with the `notify` starting status.\n\nCan we improve our solution? Yes, with safe composition.\n\nFirstly, letâ€™s introduce `CommandType` as a domain helper and refactor our `Command` type as follows.\n\n```tsx\nexport type CommandType = \"validate\" | \"process\" | \"notify\" | \"chain\";\n\nexport type Command<\n  C extends CommandType = CommandType,\n  B extends Status = Status,\n  A extends Status = Status,\n> = {\n  _type: C;\n  _before: B;\n  _after: A;\n} & (\n  | {\n      _type: \"validate\";\n      _before: \"unprocessed\";\n      _after: \"unprocessed\";\n      transactionId: string;\n    }\n  | {\n      _type: \"process\";\n      _before: \"unprocessed\";\n      _after: \"processed\";\n      transactionId: string;\n    }\n  | {\n      _type: \"notify\";\n      _before: \"processed\";\n      _after: \"processed\";\n      userId: string;\n    }\n  | {\n      _type: \"chain\";\n      _before: Status;\n      _after: Status;\n      _cmd1: Command<CommandType, B, Status>;\n      _cmd2: Command<CommandType, Status, A>;\n    }\n);\n```\n\nBy binding (imposing a connection) between `_type` , `_before` and `_after`, the sum type variants will be correctly discriminated when a value is assigned to the field discriminator or to the witness fields.\n\n```tsx\nconst y = validate(\"1\");\ny._type; // \"validate\"\ny._before; // \"unprocessed\"\ny._after; // \"unprocessed\"\n\nconst nextState = (prev: {}, command: Command) =>\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) => {})\n    .with({ _type: \"process\" }, (cmd) => {\n      cmd._before; // \"unprocessed\"\n      cmd._after; // \"processed\"\n    })\n    .with({ _type: \"notify\" }, (cmd) => {})\n    .with({ _type: \"chain\" }, (cmd) => {\n      nextState(prev, cmd._cmd1);\n      nextState(prev, cmd._cmd2);\n    })\n    .exhaustive();\n```\n\nWe can also enforce the chain constructor to accept only commands with a compatibile ending-starting status, ie. _composable_ commands, even though the `Command`'s `chain` subtype allows for _any_ transition `Status`.\n\n```tsx\ntype Chain<B extends Status, A extends Status> = Command<\"chain\", B, A>;\nconst chain =\n  <B extends Status, T extends Status>(cmd1: Command<CommandType, B, T>) =>\n  <A extends Status>(cmd2: Command<CommandType, T, A>): Chain<B, A> => ({\n    _type: \"chain\",\n    _before: cmd1._before,\n    _after: cmd2._after,\n    _cmd1: cmd1,\n    _cmd2: cmd2,\n  });\n```\n\nFor example,\n\n```tsx\nconst x = chain(validate(\"1\"))(chain(process(\"1\"))(process(\"1\")));\n```\n\nwould generate a compile error as the chain `validate -> process -> process` is not valid: `process` ends with a `processed` status, so only a `notify` command can follow.\n\nNote that the resulting `_before` and `_after` properties take in account the entire nested `chain` of commands\n\n```tsx\nconst x = chain(validate(\"1\"))(chain(process(\"1\"))(notify(\"1\")));\nx._type; // chain\nx._before; // \"unprocessed\"\nx._after; // \"processed\"\n```\n\n# When should I use GADT?\n\nEssentially, GADTs allow for constrains on type parameters based on the value constructor, enabling ADTâ€™s returned value type refinement. Pattern Matching is a side tool working elegantly and safely with GADTs/ADTs. They can be extremely effective in a variety of scenarios, including but not limited to:\n\n- Compilers or interpreters Abstract Syntax Trees\n- Building domain-specific languages\n- Modeling systems and transitions state\n- Complex data structure manipulation and safe composition\n\nGenerally speaking, GADTs/ADTs should be considered whenever we want the type system to ensure safety, correctness and expressiveness of our solution.\n\nHowever, they add complexity that must be weighed against their benefits as they might not be helpful or even harmful. If your application is simple and small enough, setting up a GADT or an ADT could be more expensive than the advantages they come with. For example,\n\n- when extensibility is not an issue as you are building a system that is unlikely to expand (you can always refactor it afterwards, thus saving certain upfront costs).\n- when you are designing something to be thrown away, eg. proof of concepts or early MVPs\n\nDeciding whether to use a GADT/ADT at design time is not always easy. A common approach is to first outline your system, and then evaluate if a GADT/ADT option emerges from the needs.\n\n---\n*All code available [here](https://github.com/arabello/ts-gadt).*\n\n1. [https://nrinaudo.github.io/far-more-adt](https://nrinaudo.github.io/far-more-adt)\n2. [https://github.com/gcanti/talks/blob/master/talks/adt/adt.md](https://github.com/gcanti/talks/blob/master/talks/adt/adt.md)\n3. [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types)\n4. [https://wiki.haskell.org/Type_witness](https://wiki.haskell.org/Type_witness)\n5. [https://v2.ocaml.org/manual/gadts-tutorial.html](https://v2.ocaml.org/manual/gadts-tutorial.html)\n","slug":"typescript-algebraic-data-types"}},"__N_SSG":true}