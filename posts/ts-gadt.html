<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/d3df112486f97f47.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/6a09e76dd70f5c43.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/60da0364ed65e94f.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-391d230ff561ad70.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-470ffcdffff046a6.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-63ca0db754963d5f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-fe16858a6c66df19.js" async="" crossorigin=""></script><script src="/_next/static/chunks/91fb74bf-2aa3af9a704fc984.js" async=""></script><script src="/_next/static/chunks/250-a62c470a1cd2819c.js" async=""></script><script src="/_next/static/chunks/288-9c80eb3af8234c4a.js" async=""></script><script src="/_next/static/chunks/app/posts/%5Bslug%5D/page-addaee46f7425911.js" async=""></script><script src="/_next/static/chunks/app/posts/page-d840912f6a549c85.js" async=""></script><title>Practicing Typescript: Generalized Algebraic Data Types</title><meta name="description" content="How GADT and Pattern Matching look like in Typescript? Let&#x27;s find out with an hands-on exercise"/><meta property="og:title" content="Practicing Typescript: Generalized Algebraic Data Types"/><meta property="og:description" content="How GADT and Pattern Matching look like in Typescript? Let&#x27;s find out with an hands-on exercise"/><meta property="og:image" content="https://matteopellegrino.dev/assets/posts/ts-gadt.webp"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:type" content="article"/><meta property="article:published_time" content="204-03-04"/><meta property="article:modified_time" content="2024-03-04"/><meta property="article:author" content="Matteo Pellegrino"/><meta property="article:section" content="Software Engineering"/><meta property="article:tag" content="typescript"/><meta property="article:tag" content="algebraic data types"/><meta property="article:tag" content="pattern matching"/><meta property="article:tag" content="scala"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@mttpll"/><meta name="twitter:creator" content="@mttpll"/><meta name="twitter:title" content="Practicing Typescript: Generalized Algebraic Data Types"/><meta name="twitter:description" content="How GADT and Pattern Matching look like in Typescript? Let&#x27;s find out with an hands-on exercise"/><meta name="twitter:image" content="https://matteopellegrino.dev/assets/posts/ts-gadt.webp"/><meta name="twitter:image:width" content="1200"/><meta name="twitter:image:height" content="630"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="icon" href="/icon.svg?21ad0ba3cb31d69f" type="image/svg+xml" sizes="any"/><link rel="apple-touch-icon" href="/apple-icon.png?9a687aff33a9f941" type="image/png" sizes="180x180"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><div class="min-vh-100"><div class="bg-gradient-custom"></div><div class="min-vh-100"><div class="bg-gradient-custom"></div><div class="container-centered d-flex flex-column p-2 p-md-3 pt-md-4"><div class="card shadow-sm border-0 rounded-3 mt-4 p-3 p-md-4 fs-6 fw-light d-flex flex-row align-items-center gap-3"><div class="text-center"><a src="/assets/icons/chevron-left.svg" alt="back icon link" width="24" height="24" href="/posts"><img alt="back icon link" href="/posts" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/chevron-left.svg"/></a></div><div class="d-flex flex-column flex-grow-1"><div class="fs-4 fw-medium text-primary flex-grow-1">Practicing Typescript: Generalized Algebraic Data Types</div><div class="fs-6 fw-light text-muted">2024-03-04</div></div><div class="text-center"><a src="/assets/icons/home.svg" alt="home icon link" width="24" height="24" href="/"><img alt="home icon link" href="/" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/home.svg"/></a></div></div></div><div style="position:relative;height:280px;width:100%" class="mt-4 mt-md-0"><img alt="post header image" loading="lazy" decoding="async" data-nimg="fill" class="post-header-image" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-position:center 60%;color:transparent" src="/assets/posts/ts-gadt.webp"/></div><div class="container-centered d-flex flex-column p-2 p-md-3 pt-md-4"><div class="card shadow-sm border-0 rounded-3 mt-4 p-3 p-md-4 fs-6 fw-light undefined"><div><p>On November 11th 2023, <a href="https://buildo.com/">we</a> hosted the <a href="https://www.scala-italy.it/">Scala Italy</a> meetup in our Milan’s office. A talk by <a href="https://nrinaudo.github.io/">Nicolas Rinaudo</a> titled <em><a href="https://www.scala-italy.it/speakers/nicolas-rinaudo">"Far more than you’ve ever wanted to know about ADTs”<sup>1</sup></a></em> grabbed my attention. Algebraic Data Types (ADT) is a noteworthy concept in Software Engineering, particularly in functional programming and type theory. Thanks to this presentation, I better realized its effectiveness on a more pragmatic level.</p>
<p>At the same time I was looking deeper into Typescript’s type system, so I asked myself:</p>
<blockquote>
  <p>“How Generalized Algebraic Data Types (GADT) and Pattern Matching would look like in Typescript?”</p>
</blockquote>
<p>This post aims to answer it. Keep in mind, it's not a deep theoretical analysis, but an attempt for a practical insight on ADTs and Pattern Matching.</p>
<p>As a toy case study, we model a naive payment transactions system with the following assumptions:</p>
<ul>
<li>Transaction-specific commands: <code>validate</code> and <code>process</code></li>
<li>A command to alert users: <code>notify</code></li>
<li>A transaction may be in <code>unprocessed</code> or <code>processed</code> status.</li>
</ul>
<hr />
<h2 id="adtfundamentals">ADT Fundamentals</h2>
<p>Let's quickly recall the basic ADT concepts<sup>2</sup> before starting coding.</p>
<p>A <em>sum type</em> is a&nbsp;disjoint&nbsp;union of values (sets). In plain words, the sum of a given two or more types is a set containing the values of one of the component types. Essentially, it is like a logical <code>OR</code> (disjunction) between types.</p>
<pre><code>Sum(A, B) = A OR B
</code></pre>
<p>It expresses the <em>alternation</em> of the component types: <code>A</code> or <code>B</code> , but not both.</p>
<p>The simplest sum type we can think of is <code>boolean</code> which is the sum type of <code>true</code> and <code>false</code> .</p>
<ul>
<li><code>true</code> is a set containing a single value</li>
<li><code>false</code> is a set containing a single value</li>
<li><code>boolean</code> is a set containing either the <code>true</code> or <code>false</code> value</li>
</ul>
<pre><code>boolean = true OR false
</code></pre>
<p>Why “<em>sum”</em> type? Because its cardinality (number of possible values) is the algebraic <em>sum</em> of the cardinalities of its component types.</p>
<pre><code>Boolean_cardinality = true_cardinality + false_cardinality = 1 + 1 = 2
</code></pre>
<p>A <em>product</em> type is compounded structure containing values of various types. In plain words, the product of a given two or more types is a collection of all the component types. Essentially, it is like a logical <code>AND</code> (conjunction) between types.</p>
<pre><code>Product(A, B) = A AND B
</code></pre>
<p>It corresponds to the Cartesian product in set theory and it expresses the <em>combination</em> of the component types: <code>A</code> and <code>B</code> together.</p>
<p><code>tuple</code> and <code>records</code> data structures are examples of product types.</p>
<pre><code>BooleanTuple = [Boolean, Boolean]
</code></pre>
<p>Why “<em>product”</em> type? Because its cardinality (number of possible values) is the algebraic <em>product</em> of the cardinalities of its component types. For instance, variables of <code>BooleanTuple</code> type can assume 4 values</p>
<pre><code class="tsx language-tsx">[true, false]
[false, true]
[true, true]
[false, false]
</code></pre>
<p>as</p>
<pre><code class="tsx language-tsx">BooleanTuple_cardinality = Boolean_cardinality * Boolean_cardinality = 2 * 2 = 4
</code></pre>
<p>An Algebraic Data Type (ADT) is a potentially recursive sum type of product types, ie. an arbitrary structure repeatedly combining sum and products types. For instance:</p>
<pre><code>ADT = A OR (C AND D) OR {nested: ADT}
</code></pre>
<p>We are now ready to see how these concepts apply in Typescript, but first a little disclaimer on formality:</p>
<blockquote>
  <p>In languages with a nominal type system like Scala, defining a sum or product type produces <em>new</em> types with a new set of potential values. Therefore, the above formal definitions are valid at implementation level.</p>
  <p>Instead, in a structural type system, all possible values already exist: new types merely define sub-sets. Therefore, we cannot create sum or product types in Typescript as per formal definitions: we can only describe already existing <em>nominal</em> types. Nevertheless, from a practical standpoint, we can define types <em>acting like</em> the sum and product types and still fully meet our objectives.</p>
</blockquote>
<hr />
<h2 id="basicadt">Basic ADT</h2>
<p>In Typescript, the union <code>|</code> type operator creates a disjoint (discriminated) union between types. It's a useful tool for shaping our transaction commands.</p>
<pre><code class="tsx language-tsx">type Command = "validate" | "process" | "notify";
</code></pre>
<p>Given a value of standard union type, the compiler cannot infer, without type guards, which of the component type is at a given moment.</p>
<p>A <em>discriminator</em> field, ie. a literal type property, helps the compiler to differentiate between the variants. Such types are known as <em>tagged unions<sup>3</sup></em> and they qualify as <em>sum types.</em></p>
<pre><code class="tsx language-tsx">type Command = { _type: "validate" } | { _type: "process" } | { _type: "notify" };
</code></pre>
<p>Commands may require extra details to carry out their tasks. For instance:</p>
<pre><code class="tsx language-tsx">export type Command =
  | { _type: "validate"; transactionId: string }
  | { _type: "process"; transactionId: string }
  | { _type: "notify"; userId: string };
</code></pre>
<p>The <code>Command</code> type acts as contract with the outside world; consumers may use constructors to create commands with ease, for example:</p>
<pre><code class="tsx language-tsx">export const validate = (transactionId: string): Command =&gt; ({
  _type: "validate",
  transactionId: "&lt;uuid&gt;",
});
</code></pre>
<p>Suppose we intend to combine or <em>chain</em> commands like <code>validate</code> and <code>process</code>. How can we set this up?</p>
<p>We can extend the <code>Command</code> definition with a new compounded type acting as a container for commands themselves.</p>
<pre><code class="tsx language-tsx">export type Command =
  | { _type: "validate"; transactionId: string }
  | { _type: "process"; transactionId: string }
  | { _type: "notify"; userId: string }
  | { _type: "chain"; _cmd1: Command; _cmd2: Command };
</code></pre>
<p>The <code>chain</code> container acts as a <em>product type</em> enabling the recursively combination of <code>Command</code> values, even another <code>chain</code>. We notice that <code>Command</code> is now an ADT because it is:</p>
<ul>
<li>a recursive</li>
<li>sum type</li>
<li>of product types</li>
</ul>
<hr />
<h1 id="patternmatching">Pattern Matching</h1>
<p>Suppose an arbitrary state for our transactions system</p>
<pre><code class="tsx language-tsx">type State = {
  /** */
};
</code></pre>
<p>and a function that computes the new state based on a <code>Command</code> used to execute the system business logic.</p>
<pre><code class="tsx language-tsx">const nextState = (prev: State, command: Command): State =&gt; {
  /** */
};
</code></pre>
<p>Our goal is to provide a skeleton for <code>nextState</code> implementation, ensuring that:</p>
<ul>
<li>The <code>Command</code> type is properly discriminated and narrowed, allowing safe data access for each command according to its type.</li>
<li>Logical branches should be fully exhausted, meaning that <code>Command</code> cases must be precisely recognized and managed at compile time. If a new command is added or removed without a proper handling, a compile error should be raised.</li>
</ul>
<h2 id="naiveswitch">Naive switch</h2>
<p>We can begin in the simplest way by applying a switch statement to the discriminator field.</p>
<pre><code class="tsx language-tsx">const nextState = (prev: State, command: Command): State =&gt; {
  switch (command._type) {
    case "validate":
      command.userId; // compile time error
      return prev;
    case "process":
      // ...
      return prev;
    case "notify":
      // ...
      return prev;
    case "chain":
      // ...
      return prev;
  }
};
</code></pre>
<p>The <code>command</code> type is narrowed within each branch. For example, trying to access the <code>userId</code> property inside the <code>validate</code> case results in a compilation error.</p>
<pre><code>Property 'userId' does not exist on type '{ _type: "validate"; transactionId: string; }'. ts(2339)
</code></pre>
<p>This meets our first goal. Now, let’s add a new <code>Command</code> component type.</p>
<pre><code class="tsx language-tsx">export type Command =
  // [...]
  { _type: "newCommand" };
</code></pre>
<p>The compiler raises an error on the <code>nextState</code> function</p>
<pre><code>Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
</code></pre>
<p>stating that the function’s return type can be <code>State | undefined</code> due to the switch statement being <em>non</em>-exhaustive. The error is raised as a mismatch between the declared and the inferred return type.</p>
<p>We may drop the explicit declaration, but we would move the responsibility of a producer’s change to the consumer!</p>
<pre><code class="diff language-diff">- const nextState = (prev: State, command: Command): State =&gt; { /** */ }
+ const nextState = (prev: State, command: Command) =&gt; { /** */ }
---     ^ inferred return type is State | undefined
</code></pre>
<pre><code class="tsx language-tsx">// Consumer
const newState: State = nextState(prevState, validate("123"));
//    ^ Type 'State | undefined' is not assignable to type 'State'.
//        Type 'undefined' is not assignable to type 'State'.ts(2322)
</code></pre>
<p>Additionally, there are other limitations when working with the native switch. For example</p>
<ul>
<li>The inability to use logical operators in the case statement. The reason being, the logical expressions are evaluated before being compared to the&nbsp;switch&nbsp;value.</li>
<li>It does not restrict developers from duplicating a branch because the switch statement only compares values.</li>
</ul>
<pre><code class="tsx language-tsx">const nextState = (prev: State, command: Command): State =&gt; {
  switch (command._type) {
    case "validate" || "process": // ⛔️ Always "validate"
      // ...
      return prev;
    case "process":
      // ...
      return prev;
    case "process": // ⛔️ Duplicated branch: compiler won't complain
      // ...
      return prev;
    case "notify":
      // ...
      return prev;
    case "chain":
      // ...
      return prev;
  }
};
</code></pre>
<p>With reference to our secondary objective, the resulting developer experience and potential side effects isn't great. Is there room for improvement?</p>
<h2 id="thirdpartypatternmatching">Third Party Pattern Matching</h2>
<p><a href="https://docs.scala-lang.org/tour/pattern-matching.html">Pattern matching is a mechanism for checking a value against a pattern</a>. A successful match can also <em>deconstruct</em> a value into its constituent parts.</p>
<p>Unfortunately, Typescript does not <em>yet</em> (🤞) provide a native pattern matching, but we can rely on third-party libraries.</p>
<p>The one I am most content with is <a href="https://github.com/gvergnaud/ts-pattern"></a><em>ts-pattern.</em> I would not dive into the syntax and mechanisms of the library: it is pretty intuitive and its <a href="https://github.com/gvergnaud/ts-pattern">documentation</a> is well-written. I would focus on the benefits of using <em>ts-pattern</em>.</p>
<p>Let’s refactor <code>nextState</code>.</p>
<pre><code class="tsx language-tsx">import { match } from "ts-pattern";

type State = {
  /** */
};

const nextState = (prev: State, command: Command): State =&gt;
  match(command)
    .with({ _type: "validate" }, (cmd) =&gt; {
      // ...
      return prev;
    })
    .with({ _type: "process" }, (cmd) =&gt; {
      // ...
      return prev;
    })
    .with({ _type: "notify" }, (cmd) =&gt; {
      // ...
      return prev;
    })
    .with({ _type: "chain" }, (cmd) =&gt; {
      // ...
      return prev;
    })
    .exhaustive();
</code></pre>
<p>Similarly as before</p>
<ul>
<li>we are discriminating over the <code>_type</code> field by matching on a portion of the command object</li>
<li>the <code>cmd</code> variable is properly narrowed</li>
<li>branches are exhaustive</li>
</ul>
<p>If we remove the <code>notify</code> command branch we get an error on the <code>exhaustive</code> call</p>
<pre><code>This expression is not callable.
    Type 'NonExhaustiveError&lt;{ _type: "notify"; userId: string; }&gt;' has no call signatures.ts(2349)
</code></pre>
<p>with a pretty straightforward description.</p>
<p>Note that the error is locally raised inside the function, even if we remove the return type declaration! I want to underlying this fact from an architectural point of view as a difference compared to the previous usage of switch statement. What if the <code>nextState</code> function firm is a software module boundary that other parts of our architecture depends on? Should adding, removing, or updating a command indirectly impacts how the consumers use the function?</p>
<p>In this way the contract with the outside world is stable even if the producer makes internal changes <em>and</em> the function firm is not explicitly declared. Instead of placing the burden of boundary responsibility on the developer, who may choose not to declare the return type, we're making better use of the type system inference.</p>
<pre><code class="diff language-diff">- const nextState = (prev: State, command: Command): State =&gt; { /** */ }
+ const nextState = (prev: State, command: Command) =&gt; { /** */ }
---        ^ inferred return type is State | undefined
--- compile error inside nextState
</code></pre>
<pre><code class="tsx language-tsx">// Consumer
const newState: State = nextState(prevState, validate("123"));
//    ✅ No error
</code></pre>
<p>Additionally, <em>ts-pattern</em> addresses the limitations found previously</p>
<pre><code class="tsx language-tsx">const nextState(prev: State, command: Command): State =&gt;
    match(command)
    .with({ _type: P.union("validate", "process") }, (cmd) =&gt; { // ✅ Logic OR
      // ...
      return prev;
    })
    .with({ _type: "notify" }, (cmd) =&gt; {
      // ...
      return prev;
    })
        .with({ _type: "notify" }, (cmd) =&gt; {.                    // ✅ Compile error raised on duplicated branch
      // ...
      return prev
    })
    .with({ _type: "chain" }, (cmd) =&gt; {
      // ...
      return prev;
    })
    .exhaustive();
</code></pre>
<p><em>ts-pattern</em> offers lots of other <a href="https://github.com/gvergnaud/ts-pattern?tab=readme-ov-file#features">features</a>, I heartily suggest looking into them.</p>
<h1 id="generalizedadtforsafecomposition">Generalized ADT for safe composition</h1>
<p>Let’s encode the status of transactions in our system</p>
<pre><code class="tsx language-tsx">export type Status = "unprocessed" | "processed";
</code></pre>
<p>and how a command modifies a transaction’s status.</p>
<pre><code class="tsx language-tsx">export type Command&lt;B extends Status, A extends Status&gt; =
  | { _type: "validate"; _before: B; _after: A; transactionId: string }
  | { _type: "process"; _before: B; _after: A; transactionId: string }
  | { _type: "notify"; _before: B; _after: A; userId: string }
  | {
      _type: "chain";
      _before: B;
      _after: A;
      _cmd1: Command&lt;B, Status&gt;;
      _cmd2: Command&lt;Status, A&gt;;
    };
</code></pre>
<p>The <code>B</code> (Before) and <code>A</code> (After) parametric types indicate that a command can be used on a transaction possessing a specific <code>Status</code> (<code>_before</code>) and results in a transaction with an identical or different <code>Status</code> (<code>_after</code>). When parametric types are describing properties of a sum type, they are referred to as <em>witness</em> types<sup>4</sup>: they enable the ADT types refinement at construction time.</p>
<p>In other words, we can now impose stricter constraints for parametric types in the constructors to refine our ADT<sup>5</sup>. This results in a <em>Generalized ADT</em>: a sum type with one or more witness types, each featuring type equality.</p>
<p>Assume that</p>
<ul>
<li><code>validate: "unprocessed" -&gt; "unprocessed"</code></li>
<li><code>process: "unprocessed" -&gt; "processed"</code></li>
<li><code>notify: "processed" -&gt; "processed"</code></li>
</ul>
<p>we refactor our constructors to <em>refine</em> the status transition per each type variant, for example</p>
<pre><code class="tsx language-tsx">export const validate = (transactionId: string): Command&lt;"unprocessed", "unprocessed"&gt; =&gt; ({
  _type: "validate",
  _before: "unprocessed",
  _after: "unprocessed",
  transactionId,
});
</code></pre>
<p>However, if we use the constructor</p>
<pre><code class="tsx language-tsx">export const y: Command&lt;"unprocessed", "unprocessed"&gt; = validate("1");
y._type; // "validate" | "process" | "notify" | "chain"
y._before; // "unprocessed"
y._after; // "unprocessed"
</code></pre>
<p>we notice that the <code>_type</code> discriminating property is not correctly narrowed due to the lack of connection between <code>_type</code>, <code>_before</code> and <code>_after</code> of each <code>Command</code> component type.</p>
<p>Dually, in the <code>nextState</code> function refactored with the new <code>Command</code></p>
<pre><code class="tsx language-tsx">const nextState = (prev: {}, command: Command&lt;Status, Status&gt;) =&gt;
  match(command)
    .with({ _type: "validate" }, (cmd) =&gt; {
      cmd._before; // Status
      cmd._after; // Status
    })
    .with({ _type: "process" }, (cmd) =&gt; {})
    .with({ _type: "notify" }, (cmd) =&gt; {})
    .with({ _type: "chain" }, (cmd) =&gt; {
      nextState(prev, cmd._cmd1);
      nextState(prev, cmd._cmd2);
    })
    .exhaustive();
</code></pre>
<p>the <code>_before</code> and <code>_after</code> properties are not narrowed based on the discriminating <code>_type</code> field.</p>
<p>Another relevant issue is that the <code>chain</code> command constructor</p>
<pre><code class="tsx language-tsx">export const chain = (
  cmd1: Command&lt;Status, Status&gt;,
  cmd2: Command&lt;Status, Status&gt;,
): Command&lt;Status, Status&gt; =&gt; ({
  _type: "chain",
  _before: cmd1._before,
  _after: cmd2._after,
  _cmd1: cmd1,
  _cmd2: cmd2,
});
</code></pre>
<p>allows to compose two transactions of <em>any</em> status. For example, the type system allows for</p>
<pre><code class="tsx language-tsx">const x: Command&lt;Status, Status&gt; = chain(validate("1"), notify("1"));
</code></pre>
<p>even though <code>validate</code> ending status is not compatible with the <code>notify</code> starting status.</p>
<p>Can we improve our solution? Yes, with safe composition.</p>
<p>Firstly, let’s introduce <code>CommandType</code> as a domain helper and refactor our <code>Command</code> type as follows.</p>
<pre><code class="tsx language-tsx">export type CommandType = "validate" | "process" | "notify" | "chain";

export type Command&lt;
  C extends CommandType = CommandType,
  B extends Status = Status,
  A extends Status = Status,
&gt; = {
  _type: C;
  _before: B;
  _after: A;
} &amp; (
  | {
      _type: "validate";
      _before: "unprocessed";
      _after: "unprocessed";
      transactionId: string;
    }
  | {
      _type: "process";
      _before: "unprocessed";
      _after: "processed";
      transactionId: string;
    }
  | {
      _type: "notify";
      _before: "processed";
      _after: "processed";
      userId: string;
    }
  | {
      _type: "chain";
      _before: Status;
      _after: Status;
      _cmd1: Command&lt;CommandType, B, Status&gt;;
      _cmd2: Command&lt;CommandType, Status, A&gt;;
    }
);
</code></pre>
<p>By binding (imposing a connection) between <code>_type</code> , <code>_before</code> and <code>_after</code>, the sum type variants will be correctly discriminated when a value is assigned to the field discriminator or to the witness fields.</p>
<pre><code class="tsx language-tsx">const y = validate("1");
y._type; // "validate"
y._before; // "unprocessed"
y._after; // "unprocessed"

const nextState = (prev: {}, command: Command) =&gt;
  match(command)
    .with({ _type: "validate" }, (cmd) =&gt; {})
    .with({ _type: "process" }, (cmd) =&gt; {
      cmd._before; // "unprocessed"
      cmd._after; // "processed"
    })
    .with({ _type: "notify" }, (cmd) =&gt; {})
    .with({ _type: "chain" }, (cmd) =&gt; {
      nextState(prev, cmd._cmd1);
      nextState(prev, cmd._cmd2);
    })
    .exhaustive();
</code></pre>
<p>We can also enforce the chain constructor to accept only commands with a compatibile ending-starting status, ie. <em>composable</em> commands, even though the <code>Command</code>'s <code>chain</code> subtype allows for <em>any</em> transition <code>Status</code>.</p>
<pre><code class="tsx language-tsx">type Chain&lt;B extends Status, A extends Status&gt; = Command&lt;"chain", B, A&gt;;
const chain =
  &lt;B extends Status, T extends Status&gt;(cmd1: Command&lt;CommandType, B, T&gt;) =&gt;
  &lt;A extends Status&gt;(cmd2: Command&lt;CommandType, T, A&gt;): Chain&lt;B, A&gt; =&gt; ({
    _type: "chain",
    _before: cmd1._before,
    _after: cmd2._after,
    _cmd1: cmd1,
    _cmd2: cmd2,
  });
</code></pre>
<p>For example,</p>
<pre><code class="tsx language-tsx">const x = chain(validate("1"))(chain(process("1"))(process("1")));
</code></pre>
<p>would generate a compile error as the chain <code>validate -&gt; process -&gt; process</code> is not valid: <code>process</code> ends with a <code>processed</code> status, so only a <code>notify</code> command can follow.</p>
<p>Note that the resulting <code>_before</code> and <code>_after</code> properties take in account the entire nested <code>chain</code> of commands</p>
<pre><code class="tsx language-tsx">const x = chain(validate("1"))(chain(process("1"))(notify("1")));
x._type; // chain
x._before; // "unprocessed"
x._after; // "processed"
</code></pre>
<h1 id="whenshouldiusegadt">When should I use GADT?</h1>
<p>Essentially, GADTs allow for constrains on type parameters based on the value constructor, enabling ADT’s returned value type refinement. Pattern Matching is a side tool working elegantly and safely with GADTs/ADTs. They can be extremely effective in a variety of scenarios, including but not limited to:</p>
<ul>
<li>Compilers or interpreters Abstract Syntax Trees</li>
<li>Building domain-specific languages</li>
<li>Modeling systems and transitions state</li>
<li>Complex data structure manipulation and safe composition</li>
</ul>
<p>Generally speaking, GADTs/ADTs should be considered whenever we want the type system to ensure safety, correctness and expressiveness of our solution.</p>
<p>However, they add complexity that must be weighed against their benefits as they might not be helpful or even harmful. If your application is simple and small enough, setting up a GADT or an ADT could be more expensive than the advantages they come with. For example,</p>
<ul>
<li>when extensibility is not an issue as you are building a system that is unlikely to expand (you can always refactor it afterwards, thus saving certain upfront costs).</li>
<li>when you are designing something to be thrown away, eg. proof of concepts or early MVPs</li>
</ul>
<p>Deciding whether to use a GADT/ADT at design time is not always easy. A common approach is to first outline your system, and then evaluate if a GADT/ADT option emerges from the needs.</p>
<hr />
<p><em>All code available <a href="https://github.com/arabello/ts-gadt">here</a>.</em></p>
<ol>
<li><a href="https://nrinaudo.github.io/far-more-adt">https://nrinaudo.github.io/far-more-adt</a></li>
<li><a href="https://github.com/gcanti/talks/blob/master/talks/adt/adt.md">https://github.com/gcanti/talks/blob/master/talks/adt/adt.md</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types</a></li>
<li><a href="https://wiki.haskell.org/Type_witness">https://wiki.haskell.org/Type_witness</a></li>
<li><a href="https://v2.ocaml.org/manual/gadts-tutorial.html">https://v2.ocaml.org/manual/gadts-tutorial.html</a></li>
</ol></div></div><div class="card shadow-sm border-0 rounded-3 mt-4 p-3 p-md-4 fs-6 fw-light d-flex flex-row align-items-center justify-content-between"><span>Any feedback or open to discuss?</span><a type="button" class="btn btn-outline-light text-reset border-0 align-items-center d-flex gap-2 justify-content-center" href="#mailgo" data-address="matteo.pelle.pellegrino" data-domain="gmail.com"><img alt="email icon" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/mail.svg"/><span>Drop me a line</span></a></div></div></div></div><script src="/_next/static/chunks/webpack-391d230ff561ad70.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/d3df112486f97f47.css\",\"style\",{\"crossOrigin\":\"\"}]\n2:HL[\"/_next/static/css/6a09e76dd70f5c43.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/60da0364ed65e94f.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[3573,[\"734\",\"static/chunks/91fb74bf-2aa3af9a704fc984.js\",\"250\",\"static/chunks/250-a62c470a1cd2819c.js\",\"288\",\"static/chunks/288-9c80eb3af8234c4a.js\",\"333\",\"static/chunks/app/posts/%5Bslug%5D/page-addaee46f7425911.js\"],\"Post\"]\n9:I[5613,[],\"\"]\nb:I[1778,[],\"\"]\nc:I[5250,[\"734\",\"static/chunks/91fb74bf-2aa3af9a704fc984.js\",\"250\",\"static/chunks/250-a62c470a1cd2819c.js\",\"288\",\"static/chunks/288-9c80eb3af8234c4a.js\",\"991\",\"static/chunks/app/posts/page-d840912f6a549c85.js\"],\"\"]\ne:I[8955,[],\"\"]\n8:T"])</script><script>self.__next_f.push([1,"51d6,"])</script><script>self.__next_f.push([1,"On November 11th 2023, [we](https://buildo.com/) hosted the [Scala Italy](https://www.scala-italy.it/) meetup in our Milan’s office. A talk by [Nicolas Rinaudo](https://nrinaudo.github.io/) titled _[\"Far more than you’ve ever wanted to know about ADTs”$^{1}$](https://www.scala-italy.it/speakers/nicolas-rinaudo)_ grabbed my attention. Algebraic Data Types (ADT) is a noteworthy concept in Software Engineering, particularly in functional programming and type theory. Thanks to this presentation, I better realized its effectiveness on a more pragmatic level.\n\nAt the same time I was looking deeper into Typescript’s type system, so I asked myself:\n\n\u003e “How Generalized Algebraic Data Types (GADT) and Pattern Matching would look like in Typescript?”\n\nThis post aims to answer it. Keep in mind, it's not a deep theoretical analysis, but an attempt for a practical insight on ADTs and Pattern Matching.\n\nAs a toy case study, we model a naive payment transactions system with the following assumptions:\n\n- Transaction-specific commands: `validate` and `process`\n- A command to alert users: `notify`\n- A transaction may be in `unprocessed` or `processed` status.\n\n---\n\n## ADT Fundamentals\n\nLet's quickly recall the basic ADT concepts$^{2}$ before starting coding.\n\nA _sum type_ is a disjoint union of values (sets). In plain words, the sum of a given two or more types is a set containing the values of one of the component types. Essentially, it is like a logical `OR` (disjunction) between types.\n\n```\nSum(A, B) = A OR B\n```\n\nIt expresses the _alternation_ of the component types: `A` or `B` , but not both.\n\nThe simplest sum type we can think of is `boolean` which is the sum type of `true` and `false` .\n\n- `true` is a set containing a single value\n- `false` is a set containing a single value\n- `boolean` is a set containing either the `true` or `false` value\n\n```\nboolean = true OR false\n```\n\nWhy “_sum”_ type? Because its cardinality (number of possible values) is the algebraic _sum_ of the cardinalities of its component types.\n\n```\nBoolean_cardinality = true_cardinality + false_cardinality = 1 + 1 = 2\n```\n\nA _product_ type is compounded structure containing values of various types. In plain words, the product of a given two or more types is a collection of all the component types. Essentially, it is like a logical `AND` (conjunction) between types.\n\n```\nProduct(A, B) = A AND B\n```\n\nIt corresponds to the Cartesian product in set theory and it expresses the _combination_ of the component types: `A` and `B` together.\n\n`tuple` and `records` data structures are examples of product types.\n\n```\nBooleanTuple = [Boolean, Boolean]\n```\n\nWhy “_product”_ type? Because its cardinality (number of possible values) is the algebraic _product_ of the cardinalities of its component types. For instance, variables of `BooleanTuple` type can assume 4 values\n\n```tsx\n[true, false]\n[false, true]\n[true, true]\n[false, false]\n```\n\nas\n\n```tsx\nBooleanTuple_cardinality = Boolean_cardinality * Boolean_cardinality = 2 * 2 = 4\n```\n\nAn Algebraic Data Type (ADT) is a potentially recursive sum type of product types, ie. an arbitrary structure repeatedly combining sum and products types. For instance:\n\n```\nADT = A OR (C AND D) OR {nested: ADT}\n```\n\nWe are now ready to see how these concepts apply in Typescript, but first a little disclaimer on formality:\n\n\u003e In languages with a nominal type system like Scala, defining a sum or product type produces _new_ types with a new set of potential values. Therefore, the above formal definitions are valid at implementation level.\n\n\u003e Instead, in a structural type system, all possible values already exist: new types merely define sub-sets. Therefore, we cannot create sum or product types in Typescript as per formal definitions: we can only describe already existing _nominal_ types. Nevertheless, from a practical standpoint, we can define types _acting like_ the sum and product types and still fully meet our objectives.\n\n---\n\n## Basic ADT\n\nIn Typescript, the union `|` type operator creates a disjoint (discriminated) union between types. It's a useful tool for shaping our transaction commands.\n\n```tsx\ntype Command = \"validate\" | \"process\" | \"notify\";\n```\n\nGiven a value of standard union type, the compiler cannot infer, without type guards, which of the component type is at a given moment.\n\nA _discriminator_ field, ie. a literal type property, helps the compiler to differentiate between the variants. Such types are known as _tagged unions$^{3}$_ and they qualify as _sum types._\n\n```tsx\ntype Command = { _type: \"validate\" } | { _type: \"process\" } | { _type: \"notify\" };\n```\n\nCommands may require extra details to carry out their tasks. For instance:\n\n```tsx\nexport type Command =\n  | { _type: \"validate\"; transactionId: string }\n  | { _type: \"process\"; transactionId: string }\n  | { _type: \"notify\"; userId: string };\n```\n\nThe `Command` type acts as contract with the outside world; consumers may use constructors to create commands with ease, for example:\n\n```tsx\nexport const validate = (transactionId: string): Command =\u003e ({\n  _type: \"validate\",\n  transactionId: \"\u003cuuid\u003e\",\n});\n```\n\nSuppose we intend to combine or _chain_ commands like `validate` and `process`. How can we set this up?\n\nWe can extend the `Command` definition with a new compounded type acting as a container for commands themselves.\n\n```tsx\nexport type Command =\n  | { _type: \"validate\"; transactionId: string }\n  | { _type: \"process\"; transactionId: string }\n  | { _type: \"notify\"; userId: string }\n  | { _type: \"chain\"; _cmd1: Command; _cmd2: Command };\n```\n\nThe `chain` container acts as a _product type_ enabling the recursively combination of `Command` values, even another `chain`. We notice that `Command` is now an ADT because it is:\n\n- a recursive\n- sum type\n- of product types\n\n---\n\n# Pattern Matching\n\nSuppose an arbitrary state for our transactions system\n\n```tsx\ntype State = {\n  /** */\n};\n```\n\nand a function that computes the new state based on a `Command` used to execute the system business logic.\n\n```tsx\nconst nextState = (prev: State, command: Command): State =\u003e {\n  /** */\n};\n```\n\nOur goal is to provide a skeleton for `nextState` implementation, ensuring that:\n\n- The `Command` type is properly discriminated and narrowed, allowing safe data access for each command according to its type.\n- Logical branches should be fully exhausted, meaning that `Command` cases must be precisely recognized and managed at compile time. If a new command is added or removed without a proper handling, a compile error should be raised.\n\n## Naive switch\n\nWe can begin in the simplest way by applying a switch statement to the discriminator field.\n\n```tsx\nconst nextState = (prev: State, command: Command): State =\u003e {\n  switch (command._type) {\n    case \"validate\":\n      command.userId; // compile time error\n      return prev;\n    case \"process\":\n      // ...\n      return prev;\n    case \"notify\":\n      // ...\n      return prev;\n    case \"chain\":\n      // ...\n      return prev;\n  }\n};\n```\n\nThe `command` type is narrowed within each branch. For example, trying to access the `userId` property inside the `validate` case results in a compilation error.\n\n```\nProperty 'userId' does not exist on type '{ _type: \"validate\"; transactionId: string; }'. ts(2339)\n```\n\nThis meets our first goal. Now, let’s add a new `Command` component type.\n\n```tsx\nexport type Command =\n  // [...]\n  { _type: \"newCommand\" };\n```\n\nThe compiler raises an error on the `nextState` function\n\n```\nFunction lacks ending return statement and return type does not include 'undefined'. ts(2366)\n```\n\nstating that the function’s return type can be `State | undefined` due to the switch statement being _non_-exhaustive. The error is raised as a mismatch between the declared and the inferred return type.\n\nWe may drop the explicit declaration, but we would move the responsibility of a producer’s change to the consumer!\n\n```diff\n- const nextState = (prev: State, command: Command): State =\u003e { /** */ }\n+ const nextState = (prev: State, command: Command) =\u003e { /** */ }\n---\t ^ inferred return type is State | undefined\n```\n\n```tsx\n// Consumer\nconst newState: State = nextState(prevState, validate(\"123\"));\n//\t^ Type 'State | undefined' is not assignable to type 'State'.\n//\t\tType 'undefined' is not assignable to type 'State'.ts(2322)\n```\n\nAdditionally, there are other limitations when working with the native switch. For example\n\n- The inability to use logical operators in the case statement. The reason being, the logical expressions are evaluated before being compared to the switch value.\n- It does not restrict developers from duplicating a branch because the switch statement only compares values.\n\n```tsx\nconst nextState = (prev: State, command: Command): State =\u003e {\n  switch (command._type) {\n    case \"validate\" || \"process\": // ⛔️ Always \"validate\"\n      // ...\n      return prev;\n    case \"process\":\n      // ...\n      return prev;\n    case \"process\": // ⛔️ Duplicated branch: compiler won't complain\n      // ...\n      return prev;\n    case \"notify\":\n      // ...\n      return prev;\n    case \"chain\":\n      // ...\n      return prev;\n  }\n};\n```\n\nWith reference to our secondary objective, the resulting developer experience and potential side effects isn't great. Is there room for improvement?\n\n## Third Party Pattern Matching\n\n[Pattern matching is a mechanism for checking a value against a pattern](https://docs.scala-lang.org/tour/pattern-matching.html). A successful match can also _deconstruct_ a value into its constituent parts.\n\nUnfortunately, Typescript does not _yet_ (🤞) provide a native pattern matching, but we can rely on third-party libraries.\n\nThe one I am most content with is [](https://github.com/gvergnaud/ts-pattern)_ts-pattern._ I would not dive into the syntax and mechanisms of the library: it is pretty intuitive and its [documentation](https://github.com/gvergnaud/ts-pattern) is well-written. I would focus on the benefits of using _ts-pattern_.\n\nLet’s refactor `nextState`.\n\n```tsx\nimport { match } from \"ts-pattern\";\n\ntype State = {\n  /** */\n};\n\nconst nextState = (prev: State, command: Command): State =\u003e\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) =\u003e {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"process\" }, (cmd) =\u003e {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"notify\" }, (cmd) =\u003e {\n      // ...\n      return prev;\n    })\n    .with({ _type: \"chain\" }, (cmd) =\u003e {\n      // ...\n      return prev;\n    })\n    .exhaustive();\n```\n\nSimilarly as before\n\n- we are discriminating over the `_type` field by matching on a portion of the command object\n- the `cmd` variable is properly narrowed\n- branches are exhaustive\n\nIf we remove the `notify` command branch we get an error on the `exhaustive` call\n\n```\nThis expression is not callable.\n\tType 'NonExhaustiveError\u003c{ _type: \"notify\"; userId: string; }\u003e' has no call signatures.ts(2349)\n```\n\nwith a pretty straightforward description.\n\nNote that the error is locally raised inside the function, even if we remove the return type declaration! I want to underlying this fact from an architectural point of view as a difference compared to the previous usage of switch statement. What if the `nextState` function firm is a software module boundary that other parts of our architecture depends on? Should adding, removing, or updating a command indirectly impacts how the consumers use the function?\n\nIn this way the contract with the outside world is stable even if the producer makes internal changes _and_ the function firm is not explicitly declared. Instead of placing the burden of boundary responsibility on the developer, who may choose not to declare the return type, we're making better use of the type system inference.\n\n```diff\n- const nextState = (prev: State, command: Command): State =\u003e { /** */ }\n+ const nextState = (prev: State, command: Command) =\u003e { /** */ }\n---\t    ^ inferred return type is State | undefined\n--- compile error inside nextState\n```\n\n```tsx\n// Consumer\nconst newState: State = nextState(prevState, validate(\"123\"));\n//\t✅ No error\n```\n\nAdditionally, _ts-pattern_ addresses the limitations found previously\n\n```tsx\nconst nextState(prev: State, command: Command): State =\u003e\n\tmatch(command)\n\t.with({ _type: P.union(\"validate\", \"process\") }, (cmd) =\u003e { // ✅ Logic OR\n\t  // ...\n\t  return prev;\n\t})\n\t.with({ _type: \"notify\" }, (cmd) =\u003e {\n\t  // ...\n\t  return prev;\n\t})\n\t\t.with({ _type: \"notify\" }, (cmd) =\u003e {.\t\t\t\t\t  // ✅ Compile error raised on duplicated branch\n\t  // ...\n\t  return prev\n\t})\n\t.with({ _type: \"chain\" }, (cmd) =\u003e {\n\t  // ...\n\t  return prev;\n\t})\n\t.exhaustive();\n```\n\n_ts-pattern_ offers lots of other [features](https://github.com/gvergnaud/ts-pattern?tab=readme-ov-file#features), I heartily suggest looking into them.\n\n# Generalized ADT for safe composition\n\nLet’s encode the status of transactions in our system\n\n```tsx\nexport type Status = \"unprocessed\" | \"processed\";\n```\n\nand how a command modifies a transaction’s status.\n\n```tsx\nexport type Command\u003cB extends Status, A extends Status\u003e =\n  | { _type: \"validate\"; _before: B; _after: A; transactionId: string }\n  | { _type: \"process\"; _before: B; _after: A; transactionId: string }\n  | { _type: \"notify\"; _before: B; _after: A; userId: string }\n  | {\n      _type: \"chain\";\n      _before: B;\n      _after: A;\n      _cmd1: Command\u003cB, Status\u003e;\n      _cmd2: Command\u003cStatus, A\u003e;\n    };\n```\n\nThe `B` (Before) and `A` (After) parametric types indicate that a command can be used on a transaction possessing a specific `Status` (`_before`) and results in a transaction with an identical or different `Status` (`_after`). When parametric types are describing properties of a sum type, they are referred to as _witness_ types$^{4}$: they enable the ADT types refinement at construction time.\n\nIn other words, we can now impose stricter constraints for parametric types in the constructors to refine our ADT$^{5}$. This results in a _Generalized ADT_: a sum type with one or more witness types, each featuring type equality.\n\nAssume that\n\n- `validate: \"unprocessed\" -\u003e \"unprocessed\"`\n- `process: \"unprocessed\" -\u003e \"processed\"`\n- `notify: \"processed\" -\u003e \"processed\"`\n\nwe refactor our constructors to _refine_ the status transition per each type variant, for example\n\n```tsx\nexport const validate = (transactionId: string): Command\u003c\"unprocessed\", \"unprocessed\"\u003e =\u003e ({\n  _type: \"validate\",\n  _before: \"unprocessed\",\n  _after: \"unprocessed\",\n  transactionId,\n});\n```\n\nHowever, if we use the constructor\n\n```tsx\nexport const y: Command\u003c\"unprocessed\", \"unprocessed\"\u003e = validate(\"1\");\ny._type; // \"validate\" | \"process\" | \"notify\" | \"chain\"\ny._before; // \"unprocessed\"\ny._after; // \"unprocessed\"\n```\n\nwe notice that the `_type` discriminating property is not correctly narrowed due to the lack of connection between `_type`, `_before` and `_after` of each `Command` component type.\n\nDually, in the `nextState` function refactored with the new `Command`\n\n```tsx\nconst nextState = (prev: {}, command: Command\u003cStatus, Status\u003e) =\u003e\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) =\u003e {\n      cmd._before; // Status\n      cmd._after; // Status\n    })\n    .with({ _type: \"process\" }, (cmd) =\u003e {})\n    .with({ _type: \"notify\" }, (cmd) =\u003e {})\n    .with({ _type: \"chain\" }, (cmd) =\u003e {\n      nextState(prev, cmd._cmd1);\n      nextState(prev, cmd._cmd2);\n    })\n    .exhaustive();\n```\n\nthe `_before` and `_after` properties are not narrowed based on the discriminating `_type` field.\n\nAnother relevant issue is that the `chain` command constructor\n\n```tsx\nexport const chain = (\n  cmd1: Command\u003cStatus, Status\u003e,\n  cmd2: Command\u003cStatus, Status\u003e,\n): Command\u003cStatus, Status\u003e =\u003e ({\n  _type: \"chain\",\n  _before: cmd1._before,\n  _after: cmd2._after,\n  _cmd1: cmd1,\n  _cmd2: cmd2,\n});\n```\n\nallows to compose two transactions of _any_ status. For example, the type system allows for\n\n```tsx\nconst x: Command\u003cStatus, Status\u003e = chain(validate(\"1\"), notify(\"1\"));\n```\n\neven though `validate` ending status is not compatible with the `notify` starting status.\n\nCan we improve our solution? Yes, with safe composition.\n\nFirstly, let’s introduce `CommandType` as a domain helper and refactor our `Command` type as follows.\n\n```tsx\nexport type CommandType = \"validate\" | \"process\" | \"notify\" | \"chain\";\n\nexport type Command\u003c\n  C extends CommandType = CommandType,\n  B extends Status = Status,\n  A extends Status = Status,\n\u003e = {\n  _type: C;\n  _before: B;\n  _after: A;\n} \u0026 (\n  | {\n      _type: \"validate\";\n      _before: \"unprocessed\";\n      _after: \"unprocessed\";\n      transactionId: string;\n    }\n  | {\n      _type: \"process\";\n      _before: \"unprocessed\";\n      _after: \"processed\";\n      transactionId: string;\n    }\n  | {\n      _type: \"notify\";\n      _before: \"processed\";\n      _after: \"processed\";\n      userId: string;\n    }\n  | {\n      _type: \"chain\";\n      _before: Status;\n      _after: Status;\n      _cmd1: Command\u003cCommandType, B, Status\u003e;\n      _cmd2: Command\u003cCommandType, Status, A\u003e;\n    }\n);\n```\n\nBy binding (imposing a connection) between `_type` , `_before` and `_after`, the sum type variants will be correctly discriminated when a value is assigned to the field discriminator or to the witness fields.\n\n```tsx\nconst y = validate(\"1\");\ny._type; // \"validate\"\ny._before; // \"unprocessed\"\ny._after; // \"unprocessed\"\n\nconst nextState = (prev: {}, command: Command) =\u003e\n  match(command)\n    .with({ _type: \"validate\" }, (cmd) =\u003e {})\n    .with({ _type: \"process\" }, (cmd) =\u003e {\n      cmd._before; // \"unprocessed\"\n      cmd._after; // \"processed\"\n    })\n    .with({ _type: \"notify\" }, (cmd) =\u003e {})\n    .with({ _type: \"chain\" }, (cmd) =\u003e {\n      nextState(prev, cmd._cmd1);\n      nextState(prev, cmd._cmd2);\n    })\n    .exhaustive();\n```\n\nWe can also enforce the chain constructor to accept only commands with a compatibile ending-starting status, ie. _composable_ commands, even though the `Command`'s `chain` subtype allows for _any_ transition `Status`.\n\n```tsx\ntype Chain\u003cB extends Status, A extends Status\u003e = Command\u003c\"chain\", B, A\u003e;\nconst chain =\n  \u003cB extends Status, T extends Status\u003e(cmd1: Command\u003cCommandType, B, T\u003e) =\u003e\n  \u003cA extends Status\u003e(cmd2: Command\u003cCommandType, T, A\u003e): Chain\u003cB, A\u003e =\u003e ({\n    _type: \"chain\",\n    _before: cmd1._before,\n    _after: cmd2._after,\n    _cmd1: cmd1,\n    _cmd2: cmd2,\n  });\n```\n\nFor example,\n\n```tsx\nconst x = chain(validate(\"1\"))(chain(process(\"1\"))(process(\"1\")));\n```\n\nwould generate a compile error as the chain `validate -\u003e process -\u003e process` is not valid: `process` ends with a `processed` status, so only a `notify` command can follow.\n\nNote that the resulting `_before` and `_after` properties take in account the entire nested `chain` of commands\n\n```tsx\nconst x = chain(validate(\"1\"))(chain(process(\"1\"))(notify(\"1\")));\nx._type; // chain\nx._before; // \"unprocessed\"\nx._after; // \"processed\"\n```\n\n# When should I use GADT?\n\nEssentially, GADTs allow for constrains on type parameters based on the value constructor, enabling ADT’s returned value type refinement. Pattern Matching is a side tool working elegantly and safely with GADTs/ADTs. They can be extremely effective in a variety of scenarios, including but not limited to:\n\n- Compilers or interpreters Abstract Syntax Trees\n- Building domain-specific languages\n- Modeling systems and transitions state\n- Complex data structure manipulation and safe composition\n\nGenerally speaking, GADTs/ADTs should be considered whenever we want the type system to ensure safety, correctness and expressiveness of our solution.\n\nHowever, they add complexity that must be weighed against their benefits as they might not be helpful or even harmful. If your application is simple and small enough, setting up a GADT or an ADT could be more expensive than the advantages they come with. For example,\n\n- when extensibility is not an issue as you are building a system that is unlikely to expand (you can always refactor it afterwards, thus saving certain upfront costs).\n- when you are designing something to be thrown away, eg. proof of concepts or early MVPs\n\nDeciding whether to use a GADT/ADT at design time is not always easy. A common approach is to first outline your system, and then evaluate if a GADT/ADT option emerges from the needs.\n\n---\n*All code available [here](https://github.com/arabello/ts-gadt).*\n\n1. [https://nrinaudo.github.io/far-more-adt](https://nrinaudo.github.io/far-more-adt)\n2. [https://github.com/gcanti/talks/blob/master/talks/adt/adt.md](https://github.com/gcanti/talks/blob/master/talks/adt/adt.md)\n3. [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#tagged-union-types)\n4. [https://wiki.haskell.org/Type_witness](https://wiki.haskell.org/Type_witness)\n5. [https://v2.ocaml.org/manual/gadts-tutorial.html](https://v2.ocaml.org/manual/gadts-tutorial.html)\n"])</script><script>self.__next_f.push([1,"a:[\"slug\",\"ts-gadt\",\"d\"]\nf:[]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d3df112486f97f47.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6a09e76dd70f5c43.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"F8SGAWst2V9qquVV6_vZw\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/ts-gadt\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"ts-gadt\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"ts-gadt\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"ts-gadt\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[\"$\",\"$L7\",null,{\"post\":{\"title\":\"Practicing Typescript: Generalized Algebraic Data Types\",\"publishDate\":\"204-03-04\",\"lastUpdate\":\"2024-03-04\",\"tags\":[\"typescript\",\"algebraic data types\",\"pattern matching\",\"scala\"],\"description\":\"How GADT and Pattern Matching look like in Typescript? Let's find out with an hands-on exercise\",\"content\":\"$8\",\"slug\":\"ts-gadt\"}}],null]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$a\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/60da0364ed65e94f.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"min-vh-100\",\"children\":[[\"$\",\"div\",null,{\"className\":\"bg-gradient-custom\"}],[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"container-centered d-flex flex-column p-2 p-md-3 pt-md-4\",\"children\":[\"$\",\"div\",null,{\"className\":\"row min-vh-100 justify-content-center align-items-center\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"display-4 text-center\",\"children\":\"404\"}],[\"$\",\"h1\",null,{\"className\":\"display-6 text-center text-muted\",\"children\":\"Page not found\"}],[\"$\",\"h4\",null,{\"className\":\"text-center mt-5 fw-light\",\"children\":[\"$\",\"$Lc\",null,{\"href\":\"/\",\"children\":\"bring me home\"}]}]]}]}]}],\"notFoundStyles\":[],\"styles\":null}]]}]}]}],null]],\"initialHead\":[false,\"$Ld\"],\"globalErrorComponent\":\"$e\",\"missingSlots\":\"$Wf\"}]]\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Practicing Typescript: Generalized Algebraic Data Types\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"How GADT and Pattern Matching look like in Typescript? Let's find out with an hands-on exercise\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Practicing Typescript: Generalized Algebraic Data Types\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"How GADT and Pattern Matching look like in Typescript? Let's find out with an hands-on exercise\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://matteopellegrino.dev/assets/posts/ts-gadt.webp\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"10\",{\"property\":\"article:published_time\",\"content\":\"204-03-04\"}],[\"$\",\"meta\",\"11\",{\"property\":\"article:modified_time\",\"content\":\"2024-03-04\"}],[\"$\",\"meta\",\"12\",{\"property\":\"article:author\",\"content\":\"Matteo Pellegrino\"}],[\"$\",\"meta\",\"13\",{\"property\":\"article:section\",\"content\":\"Software Engineering\"}],[\"$\",\"meta\",\"14\",{\"property\":\"article:tag\",\"content\":\"typescript\"}],[\"$\",\"meta\",\"15\",{\"property\":\"article:tag\",\"content\":\"algebraic data types\"}],[\"$\",\"meta\",\"16\",{\"property\":\"article:tag\",\"content\":\"pattern matching\"}],[\"$\",\"meta\",\"17\",{\"property\":\"article:tag\",\"content\":\"scala\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:site\",\"content\":\"@mttpll\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:creator\",\"content\":\"@mttpll\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:title\",\"content\":\"Practicing Typescript: Generalized Algebraic Data Types\"}],[\"$\",\"meta\",\"22\",{\"name\":\"twitter:description\",\"content\":\"How GADT and Pattern Matching look like in Typescript? Let's find out with an hands-on exercise\"}],[\"$\",\"meta\",\"23\",{\"name\":\"twitter:image\",\"content\":\"https://matteopellegrino.dev/assets/posts/ts-gadt.webp\"}],[\"$\",\"meta\",\"24\",{\"name\":\"twitter:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"25\",{\"name\":\"twitter:image:height\",\"content\":\"630\"}],[\"$\",\"link\",\"26\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"27\",{\"rel\":\"icon\",\"href\":\"/icon.svg?21ad0ba3cb31d69f\",\"type\":\"image/svg+xml\",\"sizes\":\"any\"}],[\"$\",\"link\",\"28\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?9a687aff33a9f941\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>